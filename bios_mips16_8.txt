/**************************************************************************** 

	This is the start of the pif mips controller rom on the instruction side

	This CPU will have a 16 Bit instruction rom and only a 8 bit data pathway
	
	We have the following 30 commands (2 are Null commands as we will have 
	
	one bit on the instruction ops to say if the op is a reg to reg operand 
	
	or immediate calculation.
	
	We also have no interupts on this and everything needs checked in code.
	
	We have 8 regisutres and what we usally use them for in this system
	
	S0	Always Zero for ALU instuctions
	S1	Mostly used for channel testing
	S2 	PIF send commands
	S3	PIF to receive commands
	S4	The command to be sent on that channel
	S5	Used for testing branchs
	S6	Load and store data
	S7	Ram pointer
	
	S0 also has a special function for BEQ, BNQ and BFZ commands where it can be writen for to help on the branching offset. 
		This reg is store only in the branching unit and is only used for the these commands. So this will not affect the S0 reg for ALU calulations
		If the instruction [4] bit is 1 then the branch address will look like this (Special S0 reg , offset[3:0])
		Else if the instruction [4] bit is 0. you can make a small jump. please not that this is still a signed offset.This will only do 8 offsets up and down
	

	OPS:
	
	reg to reg ops
	op[15:11] 	A[10:8] 	B[7:5] 	WB[4:2]
	
	ADD			Areg 		Breg 	WBreg
	SUB			Areg 		Breg 	WBreg
	AND			Areg 		Breg 	WBreg
	OR			Areg 		Breg 	WBreg
	XOR			Areg 		Breg 	WBreg
	MOV			Areg 		0 	  	WBreg
	BEQ			Areg 		Breg 	if [4] = 1 then branch address = (Special S0 reg , offset[3:0]) else (8x offset[3], offset [3:0]) So branches are signed
	BNQ			Areg 		Breg 	if [4] = 1 then branch address = (Special S0 reg , offset[3:0]) else (8x offset[3], offset [3:0]) So branches are signed
	JAR			Areg		Breg	0		The Areg will be the high address and the B reg will be the low address for the jump

	reg to immediate ops
	
	These call the Areg and then the ALU uses the immi value with it. This is then writen back to the Areg
	
	op[15:11] 	A[10:8] 	Imm[7:0]
	
	ADDI		Areg 		immidiate value [7:0]
	SUBI		Areg 		immidiate value [7:0]
	ANDI		Areg 		immidiate value [7:0]
	ORI			Areg 		immidiate value [7:0]
	XORI		Areg 		immidiate value [7:0]
	SLLI		Areg 		Shift[3:0]
	SRAI		Areg		Shift[3:0]
	SRUI		Areg		Shift[3:0]
	BFZ			Areg		if [4] = 1 then branch address = (Special S0 reg , offset[3:0]) else (8x offset[3], offset [3:0]) So branches are signed
	J			Jump to address[10:0]
	LB			Areg 		RAM address [7:0]
	SB			Areg 		RAM address [7:0]
	LI			Areg 		immidiate value [7:0]
	
	Memory map
	
	0x00 - 0x3F		PIF Ram
	0x40 - 0x7F		Scrach Ram
	0x80 - 0x9F		6505 Tables for CIC decoding
	0xA0 - 0xAF		Controller interface: A0 = 8 bit FIFO Write to controller, A1 8bit FIFO Read from Controller 
	0xB0 - 0xBF		EPPROM Interface
	0xC0 - 0xCF		N64 interface
	0xD0 - 0xFF		Un-reserved - Will look at a RTC interface.
	
	
	
	Controller interface
	
		A0 - 8 bit FIFO Write to controller  (upto 33 commands can be written)
		A1 - 8 bit FIFO Read from Controller (upto 36 commands can be read)
		A2 - How many Writes are to happen over the interface
		A3 - How many Reads are to happen over the interface
		A4 - Status - bit 7 = Waiting , bit 6 = Ready , bit 5 = FIFO Write Full, bit 4 = FIFO Read Full, bit 3 - Controller port 4 is being accessed, 
					bit 2 - Controller port 3 is being accessed, bit 1 - Controller port 2 is being accessed, bit 0 - Controller port 1 is being accessed
		A5 - Command - bit 7 = 0 , bit 6 = 0 , bit 5 = FIFO write empty, bit 4 = FIFO read empty, bit 3 - Controller port 4 to process, 
					bit 2 - Controller port 3 to process, bit 1 - Controller port 2 to process, bit 0 - Controller port 1 to process
				
	Epprom
	
		B0 - 8 bit FIFO Write to controller  (upto 33 commands can be written)
		B1 - 8 bit FIFO Read from Controller (upto 36 commands can be read)
		B2 - How many Writes are to happen over the interface
		B3 - How many Reads are to happen over the interface
		B4 - Status - bit 7 = Waiting , bit 6 = Ready , bit 5 = FIFO Write Full, bit 4 = FIFO Read Full, bit 0 - Epprom is being accessed
		B5 - Command - bit 7 = 0 , bit 6 = 0 , bit 5 = FIFO write empty, bit 4 = FIFO read empty, bit 0 - Epprom to process
	
	N64 Interations
	
		C0 - If a 0xFF is writen here the NMI on the N64 will become active, if 0x00 then NMI is deactive
		C1 - This is a read reg only for the reset button 0x00 is off, and 0xFF is on. so the main loop needs to check this all the time to reboot the N64
		C2 - if 0xFF is writen then the PIF Rom is disabled from begin read by the n64
		C3 - PIF Ram Offset - This is for future looking at where we can have this offset the PIF to allow larger rom's at start up. 8 bit banking

*****************************************************************************/

Main Code :
0x0000 li S7 0x3F		put 3F into address reg
0x0001 li S6 0x00		put 00 in the S6 0x3f ram reg
0x0002 li S5 0x00       put zero into S5 controller channel reg
0x0003 sb S0 S7 00		store 0x00 at 0x3F on the pif ram
0x0004 bfz S6 00		Branch back to itself if S6 is 0x00
0x0005 lw S6 S7 00		Load 0x3F and then check put result in to S6
0x0006 li S5 0x02		Load 0x02 to the reg S5 for testing if this is for cic challange
0x0007 beq S5 S6 0xE0	Branch to check crc testing - check what S6 
0x0008 li S5 0xC0		Load 0xC0 to the reg S5 for testing if this is for ram clear
0x0009 beq S5 S6 0x08	Branch to check ram clear - check what S6 
0x000A li S5 0x10		Load 0x10 to the reg S5 for testing if this is for rom disable
0x000B beq S5 S6 0xE0	Branch to check rom disable - check what S6 
0x000C li S5 0x08		Load 0x08 to the reg S5 for testing if this is for process ram
0x000D beq S5 S6 0xE0	Branch to check rom disable - check what S6 
0x000C li S5 0x05		Load 0x08 to the reg S5 for testing if this is for changing the cic details
0x000D beq S5 S6 0xE0	Branch to check cic details - check what S6 
0x000E J 0x001B			jump back to the reset check
0x000F nop

Ram Clear:
0x0010 li S7 0x00		make the S7 address reg to zero
0x0011 li S6 0x3F		Make S6 the end address
0x0011 sb S0 S7	0x00	Store S0 (Zero) to address S7
0x0012 beq S7 S6 0xFE   Go back to 0x0011
0x0013 addi S7 0x01		add 1 to reg S7
0x0014 j 0x0000			Jump back to main
0x0015 nop

Rom Disable
0x0016 li S7 0xC0		We are about to change the Rom disable flage at address 0xC2
0x0017 li S6 0x01		Set the flag in S6
0x0018 sb S6 S7 0x02    Store the flag to the reg
0x0019 j 0x0000 		Jump back to the main
0x001A nop

Reset check
0x001B li S7 0xC0		We will read the reset switch reg
0x001C lb S6 S7 0x01	Load the reset button
0x001D andi S6 0x01		We want to make sure only the LSB is one by anding the result
0x001E bfz S6 0xDE		Branch back to the main code
0x001F nop
0x0020 li S1 0xFF		we are setting up a timer for the hold reset
0x0021 li S7 0x00		make the S7 address reg to zero for getting the ram to be reseted
0x0022 li S6 0x3F		Make S6 the end address
0x0023 sb S0 S7	0x00	Store S0 (Zero) to address S7 re clear the ram
0x0024 beq S7 S6 0xFE   Go back to 0x0011
0x0025 addi S7 0x01		add 1 to reg S7
0x0026 li S7 0x70		we are going to check if there is anything in the cic temp storage
0x0027 lb S6 S7 0x0E	Load the cic temp storage and check the 3rd byte as in the documentation this should always have something in it
0x0028 bfz S6 0x27		We will branch to the cic 6502 init for the
0x0029 nop
0x002A li S6 0x24
0x002B li S7 0x7C		we are going to use these reges to load and store
0x002C li S4 0x27		this is our loop limit
0x002E lb S5 S6 0x00 	Load to S5 from S6 ad the address
0x002F sb S5 S7 0x00	Store this on the pif ram
0x0030 addi S6 0x01 	
0x0031 addi S7 0x01 	we increment the ram read and store
0x0032 beq S4 S6 0xFA	Branch back to the load S5 and S6 
0x0033 nop				We are going to go directly to the reset loop 

Reset loop: 
0x0034 li S7 0xC0		
0x0035 li S6 0xFF		We are going to use this for both the reg and timing 
0x0036 li S5 0xFF 		this is the second loop we requre to hold the reset
0x0037 sb S6 S7 0x00	Here is the activate the NMI on
0x0038 beq S0 S6 0xFF 
0x0038 subi S6 0x01		sub on from S6
0x0039 beq S0 S5 0xFC	
0x003A subi S5 0x01		sub on from S5
0x003B sb S0 S7 0x00 	turn off the NMI signal
0x003C j 0x0046			Jump to the enable rom code
0x003D nop
0x003E nop
0x003F nop

some jumps for the cic / controller and CIC changes
0x0040 j 0x0100 For cic challange 
0x0041 nop
0x0042 j 0x0200 For controller
0x0043 nop
0x0044 j 0x0300 for CIC ram change 
0x0045 nop 

rom reenable
0x0046 li S7 0xC0		We are about to change the Rom disable flage at address 0xC2
0x0047 li S6 0x00		Set the flag in S6
0x0048 sb S6 S7 0x02    Store the flag to the reg
0x0049 j 0x0000 		Jump back to the main
0x004A nop

ram status done
0x004B li S7 0x30		
0x004C sb S0 S7 0x0F	This is to make the pif ram show that the pif is completed
0x004D j 0x0000 
0x004E nop
0x004F nop

CIC init for 6502 code if required
0x0050 li S7 0x7C 		We have the first address loaded up in imm
0x0051 li S6 0x00		we are working on the cic of 00003F3F 6102 seed	
0x0052 sb S6 S7 0x00
0x0053 li S6 0x01		we are working on the cic of 00003F3F 6102 seed	
0x0054 sb S6 S7 0x00
0x0055 li S6 0x02		we are working on the cic of 00003F3F 6102 seed	
0x0056 sb S6 S7 0x3F
0x0057 li S6 0x03		we are working on the cic of 00003F3F 6102 seed	
0x0058 sb S6 S7 0x3F
0x0059 j 0x0029			Then jump back to reset code


Controller testing - we are working on the controller
0x0200 li S7 0x00		We set the pointer for reading the ram
0x0201 li S5 0x04		We want a limit of how high we can go with the channels and then put this into the eeprom read
0x0201 lb S6 S7 0x00 	we get the first byte of ram so we can testing and check howmany channels there is.
0x0202 addi S7 0x01		Next read
0x0203 bnq S6 S5 0x03
0x0204 nop
0x0205 j 0x0300 		jump to read or write EEprom code
0x0206 nop  
0x0207 beq S6 0xFD		If Zero then we add a channel
0x0208 addi S1 0x01		We say there is a channel up even if there is or not a zero -
0x0209 lb S6 S7 0x00	we now check the next byte after the channel or if things are
0x020A addi S6 0xFF		







