/**************************************************************************** 

	This is the start of the pif mips controller rom on the instruction side

	This CPU will have a 16 Bit instruction rom and only a 8 bit data pathway
	
	We have the following 30 commands (2 are Null commands as we will have 
	
	one bit on the instruction ops to say if the op is a reg to reg operand 
	
	or immediate calculation.
	
	We also have no interupts on this and everything needs checked in code.
	
	We have 8 regisutres and what we usally use them for in this system
	
	S0	Always Zero for ALU instuctions
	S1	Mostly used for channel testing
	S2 	PIF send commands
	S3	PIF to receive commands
	S4	The command to be sent on that channel
	S5	Used for testing branchs
	S6	Load and store data
	S7	Ram pointer
	
	S0 also has a special function for BEQ, BNQ and BFZ commands where it can be writen for to help on the branching offset. 
		This reg is store only in the branching unit and is only used for the these commands. So this will not affect the S0 reg for ALU calulations
		If the instruction [4] bit is 1 then the branch address will look like this (Special S0 reg , offset[3:0])
		Else if the instruction [4] bit is 0. you can make a small jump. please not that this is still a signed offset.This will only do 8 offsets up and down
	

	OPS:
	
	reg to reg ops
	op[15:11] 	A[10:8] 	B[7:5] 	WB[4:2]
	
	ADD			Areg 		Breg 	WBreg
	SUB			Areg 		Breg 	WBreg
	AND			Areg 		Breg 	WBreg
	OR			Areg 		Breg 	WBreg
	XOR			Areg 		Breg 	WBreg
	MOV			Areg 		0 	  	WBreg
	BEQ			Areg 		Breg 	if [4] = 1 then branch address = (Special S0 reg , offset[3:0]) else (8x offset[3], offset [3:0]) So branches are signed
	BNQ			Areg 		Breg 	if [4] = 1 then branch address = (Special S0 reg , offset[3:0]) else (8x offset[3], offset [3:0]) So branches are signed
	JAR			Areg		Breg	0		The Areg will be the high address and the B reg will be the low address for the jump

	reg to immediate ops
	
	These call the Areg and then the ALU uses the immi value with it. This is then writen back to the Areg
	
	op[15:11] 	A[10:8] 	Imm[7:0]
	
	ADDI		Areg 		immidiate value [7:0]
	SUBI		Areg 		immidiate value [7:0]
	ANDI		Areg 		immidiate value [7:0]
	ORI			Areg 		immidiate value [7:0]
	XORI		Areg 		immidiate value [7:0]
	SLLI		Areg 		Shift[3:0]
	SRAI		Areg		Shift[3:0]
	SRUI		Areg		Shift[3:0]
	BFZ			Areg		if [4] = 1 then branch address = (Special S0 reg , offset[3:0]) else (8x offset[3], offset [3:0]) So branches are signed
	J			Jump to address[10:0]
	LB			Areg 		RAM address [7:0]
	SB			Areg 		RAM address [7:0]
	LI			Areg 		immidiate value [7:0]
	
	Memory map
	
	0x00 - 0x3F		PIF Ram
	0x40 - 0x7F		Scrach Ram
	0x80 - 0x9F		6505 Tables for CIC decoding
	0xA0 - 0xAF		Controller interface: A0 = 8 bit FIFO Write to controller, A1 8bit FIFO Read from Controller 
	0xB0 - 0xBF		EPPROM Interface
	0xC0 - 0xCF		N64 interface
	0xD0 - 0xFF		Un-reserved - Will look at a RTC interface.
	
	
	
	Controller interface
	
		A0 - 8 bit FIFO Write to controller  (upto 33 commands can be written)
		A1 - 8 bit FIFO Read from Controller (upto 36 commands can be read)
		A2 - How many Writes are to happen over the interface
		A3 - How many Reads are to happen over the interface
		A4 - Status - bit 7 = Waiting , bit 6 = Ready , bit 5 = FIFO Write Full, bit 4 = FIFO Read Full, bit 3 - Controller port 4 is being accessed, 
					bit 2 - Controller port 3 is being accessed, bit 1 - Controller port 2 is being accessed, bit 0 - Controller port 1 is being accessed
		A5 - Command - bit 7 = 0 , bit 6 = 0 , bit 5 = FIFO write empty, bit 4 = FIFO read empty, bit 3 - Controller port 4 to process, 
					bit 2 - Controller port 3 to process, bit 1 - Controller port 2 to process, bit 0 - Controller port 1 to process
				
	Epprom
	
		B0 - 8 bit FIFO Write to controller  (upto 33 commands can be written)
		B1 - 8 bit FIFO Read from Controller (upto 36 commands can be read)
		B2 - How many Writes are to happen over the interface
		B3 - How many Reads are to happen over the interface
		B4 - Status - bit 7 = Waiting , bit 6 = Ready , bit 5 = FIFO Write Full, bit 4 = FIFO Read Full, bit 0 - Epprom is being accessed
		B5 - Command - bit 7 = 0 , bit 6 = 0 , bit 5 = FIFO write empty, bit 4 = FIFO read empty, bit 0 - Epprom to process
	
	N64 Interations
	
		C0 - If a 0xFF is writen here the NMI on the N64 will become active, if 0x00 then NMI is deactive
		C1 - This is a read reg only for the reset button 0x00 is off, and 0xFF is on. so the main loop needs to check this all the time to reboot the N64
		C2 - if 0xFF is writen then the PIF Rom is disabled from begin read by the n64
		C3 - PIF Ram Offset - This is for future looking at where we can have this offset the PIF to allow larger rom's at start up. 8 bit banking

*****************************************************************************/

Main_Code :
li S7 0x3F		put 3F into address reg
li S6 0x00		put 00 in the S6 0x3f ram reg
li S5 0x00       put zero into S5 controller channel reg
sb S0 S7 00		store 0x00 at 0x3F on the pif ram
bfz S6 00		Branch back to itself if S6 is 0x00
lw S6 S7 00		Load 0x3F and then check put result in to S6
li S5 0x02		Load 0x02 to the reg S5 for testing if this is for cic challange
beq S5 S6 0xE0	Branch to check crc testing - check what S6 
li S5 0xC0		Load 0xC0 to the reg S5 for testing if this is for ram clear
beq S5 S6 0x08	Branch to check ram clear - check what S6 
li S5 0x10		Load 0x10 to the reg S5 for testing if this is for rom disable
beq S5 S6 0xE0	Branch to check rom disable - check what S6 
li S5 0x08		Load 0x08 to the reg S5 for testing if this is for process ram
beq S5 S6 0xE0	Branch to check rom disable - check what S6 
li S5 0x05		Load 0x08 to the reg S5 for testing if this is for changing the cic details
beq S5 S6 0xE0	Branch to check cic details - check what S6 
J 0x001B			jump back to the reset check
nop

Ram_Clear:
li S7 0x00		make the S7 address reg to zero
li S6 0x3F		Make S6 the end address
sb S0 S7	0x00	Store S0 (Zero) to address S7
beq S7 S6 0xFE   Go back to 0x0011
addi S7 0x01		add 1 to reg S7
j 0x0000			Jump back to main
nop

Rom_Disable:
li S7 0xC0		We are about to change the Rom disable flage at address 0xC2
li S6 0x01		Set the flag in S6
sb S6 S7 0x02    Store the flag to the reg
j 0x0000 		Jump back to the main
nop

Reset_check:
li S7 0xC0		We will read the reset switch reg
lb S6 S7 0x01	Load the reset button
andi S6 0x01		We want to make sure only the LSB is one by anding the result
bfz S6 0xDE		Branch back to the main code
nop
li S1 0xFF		we are setting up a timer for the hold reset
li S7 0x00		make the S7 address reg to zero for getting the ram to be reseted
li S6 0x3F		Make S6 the end address
sb S0 S70x00	Store S0 (Zero) to address S7 re clear the ram
beq S7 S6 0xFE  Go back to 0x0011
addi S7 0x01	add 1 to reg S7
li S7 0x70		we are going to check if there is anything in the cic temp storage
lb S6 S7 0x0E	Load the cic temp storage and check the 3rd byte as in the documentation this should always have something in it
bfz S6 0x27		We will branch to the cic 6502 init for the
nop
li S6 0x24
li S7 0x7C		we are going to use these reges to load and store
li S4 0x27		this is our loop limit
lb S5 S6 0x00 	Load to S5 from S6 ad the address
sb S5 S7 0x00	Store this on the pif ram
addi S6 0x01 	
addi S7 0x01 	we increment the ram read and store
beq S4 S6 0xFA	Branch back to the load S5 and S6 
nop				We are going to go directly to the reset loop 

Reset loop: 
li S7 0xC0		
li S6 0xFF		We are going to use this for both the reg and timing 
li S5 0xFF 		this is the second loop we requre to hold the reset
sb S6 S7 0x00	Here is the activate the NMI on
beq S0 S6 0xFF 
subi S6 0x01	sub on from S6
beq S0 S5 0xFC	
subi S5 0x01	sub on from S5
sb S0 S7 0x00 	turn off the NMI signal
j 0x0046			Jump to the enable rom code
nop

somejumps: // for the cic / controller and CIC changes
j 0x0100 For cic challange 
nop
j 0x0200 For controller
nop
j 0x0300 for CIC ram change 
nop 

rom reenable:
li S7 0xC0		We are about to change the Rom disable flage at address 0xC2
li S6 0x00		Set the flag in S6
sb S6 S7 0x02    Store the flag to the reg
j 0x0000 		Jump back to the main
nop

ram status: // done
li S7 0x30		
sb S0 S7 0x0F	This is to make the pif ram show that the pif is completed
j 0x0000 
nop
nop

CIC init: // for 6502 code if required
li S7 0x7C 		We have the first address loaded up in imm
li S6 0x00		we are working on the cic of 00003F3F 6102 seed	
sb S6 S7 0x00
li S6 0x01		we are working on the cic of 00003F3F 6102 seed	
sb S6 S7 0x00
li S6 0x02		we are working on the cic of 00003F3F 6102 seed	
sb S6 S7 0x3F
li S6 0x03		we are working on the cic of 00003F3F 6102 seed	
sb S6 S7 0x3F
j 0x0029			Then jump back to reset code


Controller testing: //we are working on the controller
li S7 0x00		We set the pointer for reading the ram
li S5 0x04		We want a limit of how high we can go with the channels and then put this into the eeprom read
lb S6 S7 0x00 	we get the first byte of ram so we can testing and check howmany channels there is.
addi S7 0x01		Next read
bnq S6 S5 0x03
nop
j 0x0300 		jump to read or write EEprom code
nop  
beq S6 0xFD		If Zero then we add a channel
addi S1 0x01		We say there is a channel up even if there is or not a zero -
lb S6 S7 0x00	we now check the next byte after the channel or if things are
addi S6 0xFF		







